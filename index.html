<!DOCTYPE html>
<html lang="en">
<head>
    <title>street explore</title>
    <link rel="manifest" href="manifest.json" />
    <meta property="og:description" content="next pogo clone" />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
    <link rel="stylesheet" href="styles.css">
    <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@5.5.0/dist/maplibre-gl.css' />
    <script src='https://unpkg.com/maplibre-gl@5.5.0/dist/maplibre-gl.js'></script>
    <script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.min.js"></script>

</head>
<body>
<script type="importmap">
    {
        "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
    }
</script>
<div id="map"></div>

<script type="module">

//global vars
const lerpFactor = 0.4; // Adjust for speed (closer to 1 = faster)
let newBearing = 0;
let newPitch = 0;
let maxPitch = 80;
let minPitch = 0;

    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const map = new maplibregl.Map({
        container: 'map',
        style:
            'https://tiles.openfreemap.org/styles/liberty',
        zoom: 18,
        maxZoom: 19,
        minZoom: 16,
        center: [59.408384, 10.452992],
        pitch: 75,
        maxPitch: 80,
        interactive: true,
        projection: 'globe',
        canvasContextAttributes: {antialias: true} // create the gl context with MSAA antialiasing, so custom layers are antialiased
    });

    // parameters to ensure the model is georeferenced correctly on the map
    const modelOrigin = [59.408384, 10.452992];
    const modelAltitude = 0;
    const modelRotate = [Math.PI / 2, 0, 0];

    const modelAsMercatorCoordinate = maplibregl.MercatorCoordinate.fromLngLat(
        modelOrigin,
        modelAltitude
    );

    // transformation parameters to position, rotate and scale the 3D model onto the map
    const modelTransform = {
        translateX: modelAsMercatorCoordinate.x,
        translateY: modelAsMercatorCoordinate.y,
        translateZ: modelAsMercatorCoordinate.z,
        rotateX: modelRotate[0],
        rotateY: modelRotate[1],
        rotateZ: modelRotate[2],
        /* Since our 3D model is in real world meters, a scale transform needs to be
        * applied since the CustomLayerInterface expects units in MercatorCoordinates.
        */
        scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()
    };


        const customLayer = {
            id: '3d-model',
            type: 'custom',
            renderingMode: '3d',
            onAdd(map, gl) {
                this.camera = new THREE.Camera();
                this.scene = new THREE.Scene();

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(100, 100, 100);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                directionalLight.shadow.camera.near = 0.1;
                directionalLight.shadow.camera.far = 2000;
                directionalLight.shadow.camera.left = -500;
                directionalLight.shadow.camera.right = 500;
                directionalLight.shadow.camera.top = 500;
                directionalLight.shadow.camera.bottom = -500;

                directionalLight.shadow.mapSize.width = 4096;
                directionalLight.shadow.mapSize.height = 4096;

                const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
                const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = modelAsMercatorCoordinate.z + 0.01;
                ground.receiveShadow = true;
                this.scene.add(ground);
this.currentPosition = {
    x: modelTransform.translateX,
    y: modelTransform.translateY,
    z: modelTransform.translateZ
};

this.targetPosition = {
    x: modelTransform.translateX,
    y: modelTransform.translateY,
    z: modelTransform.translateZ
};

                const loader = new GLTFLoader();
                loader.load(
                    'https://maplibre.org/maplibre-gl-js/docs/assets/34M_17/34M_17.gltf',
                    (gltf) => {
                        gltf.scene.traverse(function (node) {
                            if (node.isMesh || node.isLight) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });
                        this.model = gltf.scene;
                        this.scene.add(this.model);

                    }
                );
                this.map = map;

                this.renderer = new THREE.WebGLRenderer({
                    canvas: map.getCanvas(),
                    context: gl,
                    antialias: true
                });
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                this.renderer.autoClear = false;
            },
            render(gl, args) {

//model loop

if (this.model) {
this.model.rotation.y += 0.001; // Rotate around Y-axis
this.model.position.y += 0; // Move up
}

// Smooth interpolation (lerp)

this.currentPosition.x += (this.targetPosition.x - this.currentPosition.x) * lerpFactor;
this.currentPosition.y += (this.targetPosition.y - this.currentPosition.y) * lerpFactor;
this.currentPosition.z += (this.targetPosition.z - this.currentPosition.z) * lerpFactor;


                const rotationX = new THREE.Matrix4().makeRotationAxis(
                    new THREE.Vector3(1, 0, 0),
                    modelTransform.rotateX
                );
                const rotationY = new THREE.Matrix4().makeRotationAxis(
                    new THREE.Vector3(0, 1, 0),
                    modelTransform.rotateY
                );
                const rotationZ = new THREE.Matrix4().makeRotationAxis(
                    new THREE.Vector3(0, 0, 1),
                    modelTransform.rotateZ
                );

                const m = new THREE.Matrix4().fromArray(args.defaultProjectionData.mainMatrix);
                const l = new THREE.Matrix4()
.makeTranslation(
    this.currentPosition.x,
    this.currentPosition.y,
    this.currentPosition.z
)

                    .scale(
                        new THREE.Vector3(
                            modelTransform.scale,
                            -modelTransform.scale,
                            modelTransform.scale
                        )
                    )
                    .multiply(rotationX)
                    .multiply(rotationY)
                    .multiply(rotationZ);

                this.camera.projectionMatrix = m.multiply(l);
                this.renderer.resetState();
                this.renderer.render(this.scene, this.camera);
                this.map.triggerRepaint();
            }
        };

function mercatorToLngLat(x, y) {
    const R = 6378137;
    const lng = (x / R) * (180 / Math.PI);
    const lat = (2 * Math.atan(Math.exp(y / R)) - Math.PI / 2) * (180 / Math.PI);
    return [lng, lat];
}

function moveModelTo(lngLat) {
    const newMerc = maplibregl.MercatorCoordinate.fromLngLat(lngLat, modelAltitude);
    customLayer.targetPosition = {
        x: newMerc.x,
        y: newMerc.y,
        z: newMerc.z
    };
}

// move to your own location
const geolocateControl = new maplibregl.GeolocateControl({
  positionOptions: {
    enableHighAccuracy: true
  },
  trackUserLocation: true,
  showUserHeading: true,
  showUserLocation: false
});
map.addControl(geolocateControl);

//check  for new location
geolocateControl.on('geolocate', (event) => {
  const { latitude, longitude, accuracy } = event.coords;
  console.log(`You are at ${latitude}, ${longitude} with accuracy of ${accuracy} meters.`);
    setTimeout(() => moveModelTo([longitude, latitude]), 0);
    const now = new Date();
    //const now = new Date("Mon May 19 2025 13:19:15 GMT+0100 (British Summer Time)");
    //const now = new Date("Mon May 19 2025 23:19:15 GMT+0100 (British Summer Time)");
    //const now = new Date("Mon May 19 2025 19:19:15 GMT+0100 (British Summer Time)");
    const sunPos = SunCalc.getPosition(now, latitude, longitude);
    const sunAltitude = sunPos.altitude; // radians, -PI/2 to PI/2
    console.log(`The sun is at ${sunAltitude}, and your date is ${now}`);
    updateSkyLight(sunAltitude);
});


// Day and night colors for sky and fog
const daySkyColor = "#72e7ff";
const nightSkyColor = "#010338";

const dayFogColor = "#61b2f4";
const nightFogColor = "#10125c";

const dayHorizonColor = "#bcfcff";
const nightHorizonColor = "#23254a";

function lerpColor(colorStart, colorEnd, t) {
    // Helper to parse a hex color string like "#RRGGBB" into [red, green, blue] integers
    const parseHexColor = (hexColor) => 
        hexColor.match(/\w\w/g).map(component => parseInt(component, 16));

    const [startRed, startGreen, startBlue] = parseHexColor(colorStart);
    const [endRed, endGreen, endBlue] = parseHexColor(colorEnd);

    const lerpRed = Math.round(startRed + (endRed - startRed) * t);
    const lerpGreen = Math.round(startGreen + (endGreen - startGreen) * t);
    const lerpBlue = Math.round(startBlue + (endBlue - startBlue) * t);

    return `rgb(${lerpRed},${lerpGreen},${lerpBlue})`;
}

// Assume sunAltitude is in radians, 0 at horizon, PI/2 overhead
function updateSkyLight(sunAltitude) {
    // Normalize sunAltitude to 0..1 where 0 = night, 1 = day
    const t = Math.min(Math.max(sunAltitude * 2, 0), 1);
    console.log(`Sunaltitude: ${sunAltitude}, t for colorLerp: ${t}, sunAltitude math operation: ${sunAltitude * 2}`)

    const skyColor = lerpColor(nightSkyColor, daySkyColor, t);
    const fogColor = lerpColor(nightFogColor, dayFogColor, t);
    const horizonColor = lerpColor(nightHorizonColor, dayHorizonColor, t);

    map.setSky({
        'sky-color': skyColor,
        'sky-horizon-blend': 1,
        'horizon-color': horizonColor,
        'horizon-fog-blend': 0.5,
        'fog-color': fogColor,
        'fog-ground-blend': 0.2
    });
}



    map.on('load', () => {
//first adding visuals
        map.addLayer(customLayer);

map.addSource('flat-dem', {
  type: 'raster-dem',
  tiles: ['tiles/{z}/{x}/{y}.png'],
  tileSize: 256,
  encoding: 'mapbox',
  minzoom: 0,
  maxzoom: 0, // ðŸ‘ˆ prevent requests for missing tiles
});

    //map.setTerrain({ source: 'flat-dem', exaggeration: 0 });

    map.setSky({
        'sky-color': "#72e7ff",
        'sky-horizon-blend': 1,
        'horizon-color': "#bcfcff",
        'horizon-fog-blend': 0.5,
        'fog-color': "#61b2f4",
        'fog-ground-blend': 0.2
    });

//camera movement
map.dragRotate.disable();    // allow rotation by mouse drag (desktop)
map.touchZoomRotate.disable(); // allow pinch zoom and rotation (mobile)

map.dragPan.disable();      // disable panning (desktop + mobile)

map.keyboard.disable();     // disable keyboard navigation (optional)

map.scrollZoom.disable();   // disable scroll wheel zoom (optional)
map.boxZoom.disable();      // disable box zoom (optional)
map.doubleClickZoom.disable(); // disable zoom on double click (optional)

//camera zooming (pc)
let zoomSensitivity = 0.002;

map.getCanvas().addEventListener('wheel', (event) => {
  event.preventDefault();

  // Calculate zoom delta (invert wheel direction if needed)
  let delta = -event.deltaY * zoomSensitivity;

  // Clamp zoom within map's min/max zoom
  let newZoom = map.getZoom() + delta;
  newZoom = Math.min(Math.max(newZoom, map.getMinZoom()), map.getMaxZoom());

  map.zoomTo(newZoom);
}, { passive: false });

    let isMouseDown = false;
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let oldBearing = 0;
    let oldPitch = 75;
    let moveY = 0;
    let lastValidY = 0;

//camera panning (pc)
    document.addEventListener('mousedown', function(e) {
      isMouseDown = true;
      isDragging = false;
      startX = e.clientX;
      startY = e.clientY;

    });

    document.addEventListener('mousemove', function(e) {
      if (!isMouseDown) return;

      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

    if (map.getPitch() == minPitch || maxPitch == map.getPitch()) {
        moveY = lastValidY;
    } else {
        lastValidY = e.clientY;
        moveY = e.clientY - startY;
    }
      

      if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
        isDragging = true;
        const centerY = window.innerHeight / 2;
        newBearing = oldBearing + dx/5;
        newPitch = oldPitch - moveY/5;

        map.setBearing(newBearing);
        map.setPitch(newPitch);

        //newZoom = Math.min(Math.max(newZoom, map.getMinZoom()), map.getMaxZoom());

        console.log(map.getPitch(), " ", map.getBearing());
        console.log(`Dragging... dx=${dx}, dy=${dy}`);
      }
    });

    document.addEventListener('mouseup', function() {
      if (isDragging) {
        console.log("drag ended");
    oldBearing = map.getBearing();
      oldPitch = map.getPitch();
      } else {
        console.log("click");
      }
      isMouseDown = false;
    });

});

map.on('render', () => {
//update camera to player movement
  if (customLayer.currentPosition) {
    const mercatorCoord = new maplibregl.MercatorCoordinate(
      customLayer.currentPosition.x,
      customLayer.currentPosition.y,
      customLayer.currentPosition.z
    );
    const lngLat = mercatorCoord.toLngLat();

    const currentCenter = map.getCenter();
    // Check if position changed enough (use a tiny threshold)
    const threshold = 1e-7; // adjust if needed
    const lngDiff = Math.abs(lngLat.lng - currentCenter.lng);
    const latDiff = Math.abs(lngLat.lat - currentCenter.lat);

    if (lngDiff > threshold || latDiff > threshold) {
      map.jumpTo({ center: [lngLat.lng, lngLat.lat] });
    }
  }
});

</script>
</body>
</html>
